#include <iostream> // Подключение заголовочного файла для ввода/вывода.

using namespace std; // Используем пространство имен std.

// Функция для проверки корректности IP-адреса.
bool CheckAddress(char* ip_)
{
    int points = 0, // количество точек
        numbers = 0; // значение октета

    char* buff; // буфер для одного октета

    buff = new char[3]; // Выделение памяти для буфера.

    for (int i = 0; ip_[i] != '\0'; i++)
    { // Для каждого символа в строке IP-адреса
        if (ip_[i] <= '9' && ip_[i] >= '0') // Если символ - цифра
        {
            if (numbers > 3) return false; // Если больше трех чисел в октете, то это ошибка.
            buff[numbers++] = ip_[i]; // Копируем символ в буфер.
        }
        else
            if (ip_[i] == '.') // Если символ - точка
            {
                if (atoi(buff) > 255)
                    // Проверяем диапазон октета.
                    return false;

                if (numbers == 0)
                    // Если числа нет - ошибка.
                    return false;

                numbers = 0;
                points++;
                delete[]buff; // Освобождаем буфер.
                buff = new char[3]; // Выделяем новую память для буфера.
            }
            else return false;
    }

    if (points != 3)
        // Если количество точек в IP-адресе не 3, это ошибка.
        return false;

    if (numbers == 0 || numbers > 3)
        return false;

    return true;
}

// Функция для преобразования строки IP-адреса в беззнаковое целое число.
unsigned long CharToLong(char* ip_)
{
    unsigned long out = 0; // Число для IP-адреса.
    char* buff = new char[3]; // Буфер для хранения одного октета.

    for (int i = 0, j = 0, k = 0; ip_[i] != '\0'; i++, j++)
    {
        if (ip_[i] != '.') // Если не точка.
            buff[j] = ip_[i]; // Записываем символ в буфер.

        if (ip_[i] == '.' || ip_[i + 1] == '\0')
        {
            // Если следующий октет или последний.
            out <<= 8; // Сдвигаем число на 8 бит.

            if (atoi(buff) > 255)
                return NULL; // Если октет больше 255, это ошибка.

            out += (unsigned long)atoi(buff); // Преобразуем и добавляем к числу IP-адреса.

            k++;
            j = -1;
            delete[]buff; // Освобождаем буфер.
            buff = new char[3]; // Выделяем новую память для буфера.
        }
    }
    return out;
}

// Функция для проверки корректности маски подсети.
// Функция для проверки корректности маски подсети.
bool CheckMask(unsigned long mask)
{
    if (mask == 0)
        return false; // Если маска равна нулю, считаем её некорректной и возвращаем false.

    unsigned long maskTest = 1 << 31; // Создаем маску для проверки битов.

    for (int i = 0; i < 32; i++) // Проходим через 32 бита маски.
    {
        if (!(mask & maskTest)) // Если текущий бит равен 0 (бит в маске сброшен).
        {
            for (int j = i + 1; j < 32; j++) // Проверяем оставшиеся биты.
            {
                mask <<= 1; // Сдвигаем маску на 1 бит влево.
                if (mask & maskTest) // Если следующий бит установлен (равен 1).
                    return false; // Это означает, что маска некорректна, и возвращаем false.
            }
        }
        mask <<= 1; // Сдвигаем маску на 1 бит влево для проверки следующего бита.
    }

    return true; // Если маска соответствует стандартам CIDR, то она считается корректной и возвращаем true.
}


// Функция для преобразования 32-битного числа в строку IP-адреса и вывода на экран.
// Функция для преобразования 32-битного числа в строку IP-адреса и вывода на экран.
void WriteLongToChar(unsigned long ip)
{
    unsigned long oktet[4]; // Создаем массив для четырех октетов.
    // Преобразование 32-битного числа IP-адреса в октеты:
    oktet[0] = ip >> 24;      // Получаем самый старший октет путем сдвига вправо на 24 бита.
    oktet[1] = (ip << 8) >> 24; // Получаем следующий октет путем сдвига влево на 8 бит и затем вправо на 24 бита.
    oktet[2] = (ip << 16) >> 24; // Получаем третий октет путем сдвига влево на 16 бит и затем вправо на 24 бита.
    oktet[3] = (ip << 24) >> 24; // Получаем самый младший октет путем сдвига влево на 24 бита и затем вправо на 24 бита.

    // Выводим октеты на экран в формате "x.x.x.x":
    cout << oktet[0] << "." << oktet[1] << "." << oktet[2] << "." << oktet[3] << "\n";
}


int main()
{
    setlocale(LC_ALL, "Russian"); // Установка локали для вывода сообщений на русском языке.

    unsigned long ip, mask, host, subnet, broadcast; // Объявление переменных для IP-адреса, маски, хоста, сети и broadcast-адреса.
    char* ip_, * mask_; // Объявление указателей на строки для ввода IP-адреса и маски.
    bool flag = true; // Флаг для проверки корректности ввода.

    ip_ = new char[16]; // Выделение памяти для ввода IP-адреса.
    mask_ = new char[16]; // Выделение памяти для ввода маски.

    do
    {
        if (!flag) cout << "\nНеверно введён адрес!\n" << endl; // Вывод сообщения об ошибке, если введен некорректный IP-адрес.
        cout << "введите IP - адрес: \n> ";
        cin >> ip_; // Ввод IP-адреса.
    } while (!(flag = CheckAddress(ip_))); // Повторяем ввод, пока IP-адрес не будет корректным. Функция CheckAddress() выполняет проверку.

    ip = CharToLong(ip_); // Преобразование введенного IP-адреса в числовой формат.
    flag = true; // Сброс флага.

    do
    {
        if (!flag)
            cout << "\nНеправильная маска!\n" << endl; // Вывод сообщения об ошибке, если введена некорректная маска.
        flag = true;
        do
        {
            if (!flag)
                cout << "\nНеверно введена маска!\n" << endl; // Вывод сообщения об ошибке, если введена некорректная маска.
            cout << "введите маску подсети: \n> ";
            cin >> mask_; // Ввод маски подсети.
        } while (!(flag = CheckAddress(mask_))); // Повторяем ввод маски, пока она не будет корректной. Функция CheckAddress() выполняет проверку.
        mask = CharToLong(mask_); // Преобразование введенной маски в числовой формат.
    } while (!(flag = CheckMask(mask))); // Повторяем ввод маски, пока она не будет корректной. Функция CheckMask() выполняет проверку.

    subnet = ip & mask; // Вычисление ID подсети.
    host = ip & ~mask; // Вычисление ID хоста.
    broadcast = ip & mask | ~mask; // Вычисление broadcast-адреса.

    cout << "ID подсети:\t\t";
    WriteLongToChar(subnet); // Вывод ID подсети.

    cout << "ID хоста:\t\t";
    WriteLongToChar(host); // Вывод ID хоста.

    cout << "Broadcast адрес:\t";
    WriteLongToChar(broadcast); // Вывод broadcast-адреса.

    return 0; // Завершение программы.
}

